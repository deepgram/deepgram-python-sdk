# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ......core.api_error import ApiError
from ......core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ......core.http_response import AsyncHttpResponse, HttpResponse
from ......core.jsonable_encoder import jsonable_encoder
from ......core.request_options import RequestOptions
from ......core.unchecked_base_model import construct_type
from ......errors.bad_request_error import BadRequestError
from ......types.list_billing_fields_v1response import ListBillingFieldsV1Response


class RawFieldsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        project_id: str,
        *,
        start: typing.Optional[str] = None,
        end: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListBillingFieldsV1Response]:
        """
        Lists the accessors, deployment types, tags, and line items used for billing data in the specified time period. Use this endpoint if you want to filter your results from the Billing Breakdown endpoint and want to know what filters are available.

        Parameters
        ----------
        project_id : str
            The unique identifier of the project

        start : typing.Optional[str]
            Start date of the requested date range. Format accepted is YYYY-MM-DD

        end : typing.Optional[str]
            End date of the requested date range. Format accepted is YYYY-MM-DD

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListBillingFieldsV1Response]
            A list of billing fields for a specific project
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/projects/{jsonable_encoder(project_id)}/billing/fields",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            params={
                "start": start,
                "end": end,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListBillingFieldsV1Response,
                    construct_type(
                        type_=ListBillingFieldsV1Response,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawFieldsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        project_id: str,
        *,
        start: typing.Optional[str] = None,
        end: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListBillingFieldsV1Response]:
        """
        Lists the accessors, deployment types, tags, and line items used for billing data in the specified time period. Use this endpoint if you want to filter your results from the Billing Breakdown endpoint and want to know what filters are available.

        Parameters
        ----------
        project_id : str
            The unique identifier of the project

        start : typing.Optional[str]
            Start date of the requested date range. Format accepted is YYYY-MM-DD

        end : typing.Optional[str]
            End date of the requested date range. Format accepted is YYYY-MM-DD

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListBillingFieldsV1Response]
            A list of billing fields for a specific project
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/projects/{jsonable_encoder(project_id)}/billing/fields",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            params={
                "start": start,
                "end": end,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListBillingFieldsV1Response,
                    construct_type(
                        type_=ListBillingFieldsV1Response,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
