# This file was auto-generated by Fern from our API Definition.
# Enhanced with binary message support, comprehensive socket types, and send methods.

import json
import typing
from json.decoder import JSONDecodeError

import websockets
import websockets.sync.connection as websockets_sync_connection
from ...core.events import EventEmitterMixin, EventType
from ...core.pydantic_utilities import parse_obj_as

try:
    from websockets.legacy.client import WebSocketClientProtocol  # type: ignore
except ImportError:
    from websockets import WebSocketClientProtocol  # type: ignore

# Socket message types
from ...extensions.types.sockets import (
    SpeakV1AudioChunkEvent,
    SpeakV1ControlEvent,
    SpeakV1ControlMessage,
    SpeakV1MetadataEvent,
    SpeakV1TextMessage,
    SpeakV1WarningEvent,
)

# Response union type with binary support
V1SocketClientResponse = typing.Union[
    SpeakV1AudioChunkEvent,  # Binary audio data
    SpeakV1MetadataEvent,    # JSON metadata
    SpeakV1ControlEvent,     # JSON control responses (Flushed, Cleared)
    SpeakV1WarningEvent,     # JSON warnings
    bytes,  # Raw binary audio chunks
]


class AsyncV1SocketClient(EventEmitterMixin):
    def __init__(self, *, websocket: WebSocketClientProtocol):
        super().__init__()
        self._websocket = websocket

    def _is_binary_message(self, message: typing.Any) -> bool:
        """Determine if a message is binary data."""
        return isinstance(message, (bytes, bytearray))

    def _handle_binary_message(self, message: bytes) -> typing.Any:
        """Handle a binary message (returns as-is for audio chunks)."""
        return message

    def _handle_json_message(self, message: str) -> typing.Any:
        """Handle a JSON message by parsing it."""
        json_data = json.loads(message)
        return parse_obj_as(V1SocketClientResponse, json_data)  # type: ignore

    def _process_message(self, raw_message: typing.Any) -> typing.Tuple[typing.Any, bool]:
        """Process a raw message, detecting if it's binary or JSON."""
        if self._is_binary_message(raw_message):
            processed = self._handle_binary_message(raw_message)
            return processed, True
        else:
            processed = self._handle_json_message(raw_message)
            return processed, False

    async def __aiter__(self):
        async for message in self._websocket:
            processed_message, _ = self._process_message(message)
            yield processed_message

    async def start_listening(self):
        """
        Start listening for messages on the websocket connection.
        Handles both binary and JSON messages.

        Emits events in the following order:
        - EventType.OPEN when connection is established
        - EventType.MESSAGE for each message received (binary or JSON)
        - EventType.ERROR if an error occurs
        - EventType.CLOSE when connection is closed
        """
        await self._emit_async(EventType.OPEN, None)
        try:
            async for raw_message in self._websocket:
                parsed, is_binary = self._process_message(raw_message)
                await self._emit_async(EventType.MESSAGE, parsed)
        except (websockets.WebSocketException, JSONDecodeError) as exc:
            # Do not emit an error for a normal/clean close
            if not isinstance(exc, websockets.exceptions.ConnectionClosedOK):
                await self._emit_async(EventType.ERROR, exc)
        finally:
            await self._emit_async(EventType.CLOSE, None)

    async def recv(self) -> V1SocketClientResponse:
        """
        Receive a message from the websocket connection.
        Handles both binary and JSON messages.
        """
        data = await self._websocket.recv()
        processed_message, _ = self._process_message(data)
        return processed_message

    async def _send(self, data: typing.Any) -> None:
        """
        Send data as binary or JSON depending on type.
        """
        if isinstance(data, (bytes, bytearray)):
            await self._websocket.send(data)
        elif isinstance(data, dict):
            await self._websocket.send(json.dumps(data))
        else:
            await self._websocket.send(data)

    async def _send_model(self, data: typing.Any) -> None:
        """
        Send a Pydantic model to the websocket connection.
        """
        await self._send(data.dict(exclude_unset=True, exclude_none=True))

    # Enhanced send methods for specific message types
    async def send_text(self, message: SpeakV1TextMessage) -> None:
        """Send a text message to generate speech."""
        await self._send_model(message)

    async def send_control(self, message: SpeakV1ControlMessage) -> None:
        """Send a control message (flush, clear, etc.)."""
        await self._send_model(message)


class V1SocketClient(EventEmitterMixin):
    def __init__(self, *, websocket: websockets_sync_connection.Connection):
        super().__init__()
        self._websocket = websocket

    def _is_binary_message(self, message: typing.Any) -> bool:
        """Determine if a message is binary data."""
        return isinstance(message, (bytes, bytearray))

    def _handle_binary_message(self, message: bytes) -> typing.Any:
        """Handle a binary message (returns as-is for audio chunks)."""
        return message

    def _handle_json_message(self, message: str) -> typing.Any:
        """Handle a JSON message by parsing it."""
        json_data = json.loads(message)
        return parse_obj_as(V1SocketClientResponse, json_data)  # type: ignore

    def _process_message(self, raw_message: typing.Any) -> typing.Tuple[typing.Any, bool]:
        """Process a raw message, detecting if it's binary or JSON."""
        if self._is_binary_message(raw_message):
            processed = self._handle_binary_message(raw_message)
            return processed, True
        else:
            processed = self._handle_json_message(raw_message)
            return processed, False

    def __iter__(self):
        for message in self._websocket:
            processed_message, _ = self._process_message(message)
            yield processed_message

    def start_listening(self):
        """
        Start listening for messages on the websocket connection.
        Handles both binary and JSON messages.

        Emits events in the following order:
        - EventType.OPEN when connection is established
        - EventType.MESSAGE for each message received (binary or JSON)
        - EventType.ERROR if an error occurs
        - EventType.CLOSE when connection is closed
        """
        self._emit(EventType.OPEN, None)
        try:
            for raw_message in self._websocket:
                parsed, is_binary = self._process_message(raw_message)
                self._emit(EventType.MESSAGE, parsed)
        except (websockets.WebSocketException, JSONDecodeError) as exc:
            # Do not emit an error for a normal/clean close
            if not isinstance(exc, websockets.exceptions.ConnectionClosedOK):
                self._emit(EventType.ERROR, exc)
        finally:
            self._emit(EventType.CLOSE, None)

    def recv(self) -> V1SocketClientResponse:
        """
        Receive a message from the websocket connection.
        Handles both binary and JSON messages.
        """
        data = self._websocket.recv()
        processed_message, _ = self._process_message(data)
        return processed_message

    def _send(self, data: typing.Any) -> None:
        """
        Send data as binary or JSON depending on type.
        """
        if isinstance(data, (bytes, bytearray)):
            self._websocket.send(data)
        elif isinstance(data, dict):
            self._websocket.send(json.dumps(data))
        else:
            self._websocket.send(data)

    def _send_model(self, data: typing.Any) -> None:
        """
        Send a Pydantic model to the websocket connection.
        """
        self._send(data.dict(exclude_unset=True, exclude_none=True))

    # Enhanced send methods for specific message types
    def send_text(self, message: SpeakV1TextMessage) -> None:
        """Send a text message to generate speech."""
        self._send_model(message)

    def send_control(self, message: SpeakV1ControlMessage) -> None:
        """Send a control message (flush, clear, etc.)."""
        self._send_model(message)
